<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="iem7"><![endif]-->
<!--[if lt IE 9]><html class="lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Objective-C from Rust: objc_msgSend - sasheldon.com</title>
  <meta name="author" content="Steven Sheldon">

  
  <meta name="description" content="I previously wrote about how to interoperate between Objective-C and Rust and use a Rust macro to pass a variable number of arguments to objc_msgSe...">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://sasheldon.com/blog/2015/08/02/objective-c-from-rust-objc_msgsend/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/blog/atom.xml" rel="alternate" title="sasheldon.com" type="application/atom+xml">

  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
  <link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
  <link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-57212765-1', 'auto');
    ga('send', 'pageview');
  </script>


</head>

<body>
  <header role="banner"><hgroup>
  <h1><a href="/">sasheldon.com</a></h1>
  
</hgroup>
</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/blog/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>


<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="sasheldon.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>


<ul class="main-navigation">
  <li><a href="/">About</a></li>
  <li><a href="/blog">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
<header>
  
    <h1 class="entry-title">Objective-C from Rust: objc_msgSend</h1>
  
  
    <p class="meta">
      








  


<time datetime="2015-08-02T23:53:50-07:00"  class="updated" >Aug 02, 2015</time>
    </p>
  
</header>


  <div class="entry-content"><p>I previously wrote about how to <a href="/blog/2014/11/28/interoperating-between-objective-c-and-rust/">interoperate between Objective-C and Rust</a>
and use a Rust macro to pass a variable number of arguments to <code>objc_msgSend</code>.
Well, there&rsquo;s a problem with this: <code>objc_msgSend</code> isn&rsquo;t a variadic function!</p>

<!-- more -->

<p><code>objc_msgSend</code> is actually a &ldquo;trampoline&rdquo; that works by jumping directly to
the implementation of the method, not calling it and passing parameters.
Safely calling it requires first casting it to the type of the underlying
method implementation, like:</p>
<div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="c1">// id result = [obj description];</span>
<span class="kt">id</span> <span class="n">result</span> <span class="o">=</span> <span class="p">((</span><span class="kt">id</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">))</span><span class="n">objc_msgSend</span><span class="p">)(</span><span class="n">obj</span><span class="p">,</span> <span class="k">@selector</span><span class="p">(</span><span class="n">description</span><span class="p">));</span>
</code></pre></div>
<p>If you try to call <code>objc_msgSend</code> as if it were a variadic function,
<a href="https://github.com/servo/cocoa-rs/pull/74#issuecomment-75492331">weird things can happen</a>!</p>

<h2>Handling arguments</h2>

<p>How can we handle <code>objc_msgSend</code> in Rust? Let&rsquo;s try to write a
wrapper function that calls it correctly.
It&rsquo;s easy to see how we could do this for, say, two arguments:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">unsafe</span> <span class="k">fn</span> <span class="n">msg_send</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="o">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Object</span><span class="p">,</span> <span class="n">op</span><span class="o">:</span> <span class="n">Sel</span><span class="p">,</span> <span class="n">arg1</span><span class="o">:</span> <span class="n">A</span><span class="p">,</span> <span class="n">arg2</span><span class="o">:</span> <span class="n">B</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R</span> <span class="p">{</span>
    <span class="c1">// Transmute objc_msgSend to the type of the method implementation</span>
    <span class="k">let</span> <span class="n">msg_send_fn</span><span class="o">:</span> <span class="k">unsafe</span> <span class="k">extern</span> <span class="k">fn</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R</span> <span class="o">=</span>
        <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">mem</span><span class="o">::</span><span class="n">transmute</span><span class="p">(</span><span class="n">objc_msgSend</span><span class="p">);</span>
    <span class="n">msg_send_fn</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>But our function needs to be able to accept one argument, or no arguments,
or more than 2. This sounds a lot like function overloading, which Rust
doesn&rsquo;t support. However, there&rsquo;s a pattern that can emulate function
overloading in Rust: functions with a generic parameter. In our case,
our function could take a generic parameter that is the arguments,
represented as a tuple:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">unsafe</span> <span class="k">fn</span> <span class="n">msg_send</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="o">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Object</span><span class="p">,</span> <span class="n">op</span><span class="o">:</span> <span class="n">Sel</span><span class="p">,</span> <span class="n">args</span><span class="o">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</code></pre></div>
<p>How do we implement this now?
Well, it was easy to implement for a fixed number of arguments,
so we can let the arguments themselves handle calling <code>objc_msgSend</code>.
Let&rsquo;s add a <code>MessageArguments</code> trait and implement it for tuples:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">&gt;</span> <span class="n">MessageArguments</span> <span class="k">for</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="k">fn</span> <span class="n">send</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">obj</span><span class="o">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Object</span><span class="p">,</span> <span class="n">op</span><span class="o">:</span> <span class="n">Sel</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R</span> <span class="p">{</span>
        <span class="c1">// Transmute objc_msgSend to the type of the method implementation</span>
        <span class="k">let</span> <span class="n">msg_send_fn</span><span class="o">:</span> <span class="k">unsafe</span> <span class="k">extern</span> <span class="k">fn</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R</span> <span class="o">=</span>
            <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">mem</span><span class="o">::</span><span class="n">transmute</span><span class="p">(</span><span class="n">objc_msgSend</span><span class="p">);</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
        <span class="n">msg_send_fn</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p><a href="https://github.com/SSheldon/rust-objc/blob/2bc409b/src/message.rs#L134-L175">Using a macro</a>,
we can easily implement this trait for tuples from size 0 to some upper bound.
Our function simply becomes:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">unsafe</span> <span class="k">fn</span> <span class="n">msg_send</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="o">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Object</span><span class="p">,</span> <span class="n">op</span><span class="o">:</span> <span class="n">Sel</span><span class="p">,</span> <span class="n">args</span><span class="o">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R</span>
        <span class="n">where</span> <span class="n">T</span><span class="o">:</span> <span class="n">MessageArguments</span> <span class="p">{</span>
    <span class="n">args</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>And now we&rsquo;re no longer pretending that <code>objc_msgSend</code> is variadic!</p>

<h2>Return types</h2>

<p>There&rsquo;s one other caveat with <code>objc_msgSend</code>, though:
different versions of it are used for different return types.
Which version is used depends on the calling conventions of the architecture.</p>

<p>Let&rsquo;s encapsulate this with a simple function that returns the correct
version of <code>objc_msgSend</code> for the return type:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">msg_send_fn</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="k">unsafe</span> <span class="k">extern</span> <span class="k">fn</span><span class="p">(</span><span class="o">*</span><span class="k">mut</span> <span class="n">Object</span><span class="p">,</span> <span class="n">Sel</span><span class="p">,</span> <span class="p">...)</span> <span class="o">-&gt;</span> <span class="n">R</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</code></pre></div>
<p>We can implement this for different architectures with a
<a href="https://doc.rust-lang.org/stable/reference.html#conditional-compilation"><code>cfg</code> attribute</a>.
x86&rsquo;s calling conventions are <a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/LowLevelABI/130-IA-32_Function_Calling_Conventions/IA32.html">arguably the most complicated</a>,
so for it this function would look like:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="cp">#[cfg(target_arch = </span><span class="s">&quot;x86&quot;</span><span class="cp">)]</span>
<span class="k">fn</span> <span class="n">msg_send_fn</span><span class="o">&lt;</span><span class="n">R</span><span class="o">:</span> <span class="n">Any</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="k">unsafe</span> <span class="k">extern</span> <span class="k">fn</span><span class="p">(</span><span class="o">*</span><span class="k">mut</span> <span class="n">Object</span><span class="p">,</span> <span class="n">Sel</span><span class="p">,</span> <span class="p">...)</span> <span class="o">-&gt;</span> <span class="n">R</span> <span class="p">{</span>
    <span class="k">use</span> <span class="n">std</span><span class="o">::</span><span class="n">any</span><span class="o">::</span><span class="n">TypeId</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">type_id</span> <span class="o">=</span> <span class="n">TypeId</span><span class="o">::</span><span class="n">of</span><span class="o">::&lt;</span><span class="n">R</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">size</span> <span class="o">=</span> <span class="n">mem</span><span class="o">::</span><span class="n">size_of</span><span class="o">::&lt;</span><span class="n">R</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">if</span> <span class="n">type_id</span> <span class="o">==</span> <span class="n">TypeId</span><span class="o">::</span><span class="n">of</span><span class="o">::&lt;</span><span class="k">f32</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">||</span> <span class="n">type_id</span> <span class="o">==</span> <span class="n">TypeId</span><span class="o">::</span><span class="n">of</span><span class="o">::&lt;</span><span class="k">f64</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="n">mem</span><span class="o">::</span><span class="n">transmute</span><span class="p">(</span><span class="n">runtime</span><span class="o">::</span><span class="n">objc_msgSend_fpret</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">size</span> <span class="o">==</span> <span class="m">0</span> <span class="o">||</span> <span class="n">size</span> <span class="o">==</span> <span class="m">1</span> <span class="o">||</span> <span class="n">size</span> <span class="o">==</span> <span class="m">2</span> <span class="o">||</span> <span class="n">size</span> <span class="o">==</span> <span class="m">4</span> <span class="o">||</span> <span class="n">size</span> <span class="o">==</span> <span class="m">8</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="n">mem</span><span class="o">::</span><span class="n">transmute</span><span class="p">(</span><span class="n">runtime</span><span class="o">::</span><span class="n">objc_msgSend</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">unsafe</span> <span class="p">{</span> <span class="n">mem</span><span class="o">::</span><span class="n">transmute</span><span class="p">(</span><span class="n">runtime</span><span class="o">::</span><span class="n">objc_msgSend_stret</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>With this <code>msg_send_fn</code> function <a href="https://github.com/SSheldon/rust-objc/blob/2bc409b/src/message.rs#L14-L112">defined for each architecture</a>,
we can use it to get the correct version of <code>objc_msgSend</code> for
our return type.</p>

<p>At this point we&rsquo;re invisibly handling <code>objc_msgSend</code> correctly for any
combination of argument types and any return type. We can further
<a href="https://github.com/SSheldon/rust-objc/blob/2bc409b/src/macros.rs#L58-L83">wrap it with a macro</a>
to make it more ergonomic; in the end, calling Objective-C methods is nearly
as easy from Rust as it is in Objective-C!</p>
</div>
  
<footer>
  <p class="meta">
    
  

<span class="byline author vcard">Posted by <span class="fn">Steven Sheldon</span></span>

    








  


<time datetime="2015-08-02T23:53:50-07:00"  class="updated" >Aug 02, 2015</time>
    


  </p>
  <p class="meta">
    
      <a class="basic-alignment left" href="/blog/2014/11/28/interoperating-between-objective-c-and-rust/" title="Previous Post: Interoperating Between Objective-C and Rust">&laquo; Interoperating Between Objective-C and Rust</a>
    
    
  </p>
</footer>


</article>
</div>

      
      <aside class="sidebar">
        <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/08/02/objective-c-from-rust-objc_msgsend/">Objective-C from Rust: objc_msgSend</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/28/interoperating-between-objective-c-and-rust/">Interoperating Between Objective-C and Rust</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/12/14/simplifying-json-response-mocks-with-jinja/">Simplifying JSON Response Mocks With Jinja</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/07/07/waiting-for-octopress-2-successor/">Waiting for Octopress 2.0's Successor</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/11/15/octopress/">Octopress</a>
      </li>
    
  </ul>
</section>

      </aside>
      
    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Steven Sheldon -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>
</footer>

  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
</body>
</html>
